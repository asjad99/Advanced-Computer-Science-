 
| Algorithm                | Implementation | 
|--------------------------|------|
| Dijkstra's algorithm     |      |
| Topological sort                        |      |
|  \Shortest/longest path on a acyclic graph                         |      |
| Bellman Ford's algorithm                         |      |
| Floyd-Warshall all pairs shortest path algorithm |     |
| Finding bridges/articulation points             |     | 
| Finding strongly connected components (Tarjan's) |   | 
|  Travelling salesman problem (TSP)   |    |
|      Introduction to graph algorithms | |
|      Storage and representation of graphs (networks) on a computer |  |
|      Common graph theory problems |     | 
|      Breadth first search algorithm |   |
|      Depth first search algorithm |     |
| Spectral Graph Theory |   | 

#### Data Mining/Matrix Algorithms  Algorithms 

|   Algorithms                   | Implementation |
|-----------------------------------------------|-------------------------------------------------------------------------------------------|
| Scalable SVD                                  |      [Code](https://gist.github.com/asjad99/e87a695df10b0859ee943b8e661f0fc3)  |
| Principal Component Analysis (PCA)            |                                                                                           |
| Probabilistic Latent Semantic Indexing (PLSA) |                                                                                           |
| Latent Semantic Indexing                      |     [Code](https://gist.github.com/asjad99/e87a695df10b0859ee943b8e661f0fc3)              |
| Logistic Matrix Factorization                 |                                                                                           |
| Collaborative Filtering                       |                                                                                           |
| Compressive sensing                           |                                                                                           |
| Linear and convex programming                 |                                                                                           |
| Assoicative Rule Mining                       |                                                                                           |           
| Alpha Miner                                   |                                                                                           |           
| Flexible Heuristic Miner                      |                                                                                           |           


### AI algorithms for data products 

- A data product provides actionable information without exposing decision makers to the underlying
data or analytics. Examples include: Movie Recommendations, Production Process Improvements, Targeted Advertising etc. 



| Topic                          | Code | 
---------------------------------|------|
| Generalization and Regularization|     |
|  Hybrid-CI-System              | [Code](https://github.com/asjad99/Hybrid-CI-System) |
| Traveling Salesmen and gentic algorithms |  [Code](https://github.com/asjad99/Genetic-Algorithms) |  
| Neural Network                 |  [Code](https://github.com/asjad99/MLP) -A multi-layer Neural Network to solve the two spiral problem|

https://github.com/eriklindernoren/NapkinML
https://github.com/eriklindernoren/ML-From-Scratch



<!---
### Python Resources: 

- how to think like a CS in python
- Data Structures and algorithms in python
- Hitch Hiker's Guide to python
- SCIP in python: https://wizardforcel.gitbooks.io/sicp-in-python/content/1.html
- python env https://jacobian.org/2018/feb/21/python-environment-2018/
- Cheatsheet https://github.com/gto76/python-cheatsheet?utm_source=hackernewsletter&utm_medium=email&utm_term=code </li


Algorithms Courses:
 - Algorithmic Engineering https://people.csail.mit.edu/jshun/6886-s21/
 - CS168 Stanford 
 
 # Computatinal Photography/Vision/

Architecture 
1. https://news.ycombinator.com/item?id=30986893
2. Computer Systems 

You should be comfortable with arrays, pointers, references, classes, methods, dynamic memory allocation, recursion, linked lists, binary search trees, hashing, iterators, and function pointers.

---


 - Computational Photography
 - https://rolisz.ro/projects/
 - 
- https://jeremykun.com/2018/12/01/a-programmers-introduction-to-mathematics/
- https://maxmasnick.com/kb/
- https://chrisalbon.com/ Photography: 
https://paulstamatiou.com/photos/new-zealand/mount-cook-to-christchurch/ 
gear: https://paulstamatiou.com/stuff-i-use/


 -->


 
A-Algorithms and Complexity
B-Formal Methods, logic, Programming languages
 

- Proof
- Propositional Logic, Propositional Logic, SAT Solver, MaxSAT
- Graph Theory
- Functions and Cardinality
- Computability Theory
- Complexity Theory
    - time-hierarchy and space-hierarchy theorems
    - P vs NP
- Information Theory 
- Approximation Theory 
- Search (Tree, Graph, A*, Game Tree, MCTS) 
- Consistent hashing
- Property-preserving lossy compression
- Data with Distances (Similarity Search, Nearest Neighbor, Dimension Reduction, LSH)
- ML Intro / Generalization and Regularization
    - Linear Regression 
    - NNs, LSTMs, MANNS
    - Andrew NG, DL book, ML Yearning and 
- Linear-Algebraic Techniques: 
    - Understanding Principal Components Analysis
    - Understanding the Singular Value Decomposition
- Sampling and Estimation
- Spectral Graph Theory
- The Fourier Perspective (and other bases)
        - Chapter 4 - DIP
- Mathematical Programming and Sparse Vector/Matrix Recovery (Compressive Sensing)
        - Compressive sensing.
        - Linear and convex programming. Matrix completion.
- Privacy Preserving Data Analysis
- Intro to Differential Privacy
- Markov Decision Process 
- Reinforcement Learning 
- Associate Rule Mining
- Process Mining 
- Clustering 

 
 
 
Great Ideas in CS:  https://www.youtube.com/watch?v=uaAvVNWvi4A&index=2&t=0s&list=PLm3J0oaFux3aafQm568blS9blxtA_EWQv
 
On Complexity Theory: 
 
It is clear what it means to measure the performance of a specific algorithm A on a specific problem instance I.But complexity theory aims at describing the performance of A over the space of all problem instances and it does so by abstracting away from individual problem instances. The typical way in which we do this abstraction is by considering all problem instances of length n, and asking for upper and lower bounds on algorithmic performance (usually in terms of time and memory utilization) as a function of n. This approach is referred to as the worst-case approach, as it focused on the most challenging problem instance of each length n. If the upper bound that we can prove is one of a slow-growing function, for example, cn log n, for a small constant c, then we have a guarantee of good performance on all problem instances. But, in general, most upper and lower bound are much less useful. For example, an exponential lower bound just says some problem instances are hard, but says nothing about the practical significance of such instances. https://cacm.acm.org/magazines/2019/3/234913-lost-in-math/fulltext#FNB
 
Algorithm analysis: 
            While crude, worst-case analysis can be tremendously useful, and it is the dominant paradigm for algorithm analysis in theoretical computer science. A good worst-case guarantee is the best-case scenario for an algorithm, certifying its general-purpose utility and absolving its users from understanding which inputs are relevant to their applications. Remarkably, for many fundamental computational problems, there are algorithms with excellent worst-case performance guarantees. The lion's share of an undergraduate algorithms course comprises algorithms that run in linear or near-linear time in the worst case.
 

https://cacm.acm.org/magazines/2019/3/234929-the-seven-tools-of


 
 
 
On Logic - Halting Problem and incompleteness theorems 
On June 16, 1902, British philosopher Bertrand Russell sent a letter to Gottlob Frege, a German logician, in which he argued, by using what became known as "Russell's Paradox," that Frege's logical system was inconsistent. The letter launched a "Foundational Crisis" in mathematics, triggering an almost anguished search for proper foundations for mathematics. In 1921, David Hilbert, the preeminent German mathematician, launched a research program aimed at disposing "the foundational questions once and for all." Hilbert's Program failed; in 1931, Austrian logician Kurt Goedel proved two incompleteness theorems that proved the futility of Hilbert's Program. https://cacm.acm.org/magazines/2011/7/109895-solving-the-unsolvable/fulltext
 
The Internet: 
 
In 1992, the explosive growth of the World Wide Web began. The architecture of the Internet was commonly described as having four layers above the physical media, each providing a distinct function: a "link" layer providing local packet delivery over heterogeneous physical networks, a "network" layer providing best-effort global packet delivery across autonomous networks all using the Internet Protocol (IP), a "transport" layer providing communication services such as reliable byte streams (TCP) and datagram service (UDP), and an "application" layer. In 1993, the last major change was made to this classic Internet architecture;11 since then the scale and economics of the Internet have precluded further changes to IP.
 
 

https://cacm.acm.org/magazines/2019/3/234927-the-compositional-architecture-of-the-internet/abstract


 
 
On Boolean Satisfiability Problem (SAT)
 
The Boolean Satisfiability Problem (SAT, for short) asks whether a given Boolean formula, with Boolean gates such as AND and NOT, has some assignment of 0s and 1s to its input variables such that the formula yields the value 1. SAT has been a problem of central importance in computer science since Stephen Cook proved its NP-completeness in 1971. To resolve the P vs. NP question, one of the most outstanding open questions in computer science and mathematics, one would have to show whether SAT is or is not in P, that is, whether it can be or cannot be solved in polynomial time. https://cacm.acm.org/magazines/2014/3/172516-boolean-satisfiability/fulltext
 
 
 
On Formal Methods and Model Checkers: 
 
Verifying code is a hard problem. More and more people are doing it, though, as theorem provers and SMT solvers get more sophisticated. It will probably remain a specialist thing for the foreseeable future.
Verifying designs is much easier, but has cultural barriers to adoption. I think this is possible to change, though. Twenty years ago automated testing and code review were pretty niche things and they eventually went mainstream. Then again, code contracts was a niche thing and still is.
Hopefully this explains more about why FM is so niche, at least better than the usual “web don’t airplane” argument. Feel free to yell at me if there is any obvious mistakes I made.
 
https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/
 
 
 
At AWS, formal methods have been a big success. They have helped us prevent subtle, serious bugs from reaching production, bugs that we would not have found via any other technique. They have helped us to make aggressive optimizations to complex algorithms without sacrificing quality. So far, seven teams have used TLA+, and all have found high value in doing so. At the time of writing, more teams are starting to use TLA+. We believe that use of TLA+ will accelerate both time-to-market and quality of these projects. Executive management is now proactively encouraging teams to write TLA+ specs for new features and other significant design changes. In annual planning, managers are now allocating engineering time to use TLA+. While our results are very encouraging, some important caveats remain. Formal methods deal with models of systems, not the systems themselves, so the adage applies; “All models are wrong, some are useful.” The designer must ensure that the model captures the significant aspects of the real system. Achieving this is a difficult skill, the acquisition of which requires thoughtful practice. Also, we were solely concerned with obtaining practical benefits in our particular problem domain, and have not attempted a comprehensive survey. Therefore, mileage may vary with other tools or in other problem domains. http://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf
 
 
 
 

 
 
 

https://www.youtube.com/playlist?list=PLm3J0oaFux3aafQm568blS9blxtA_EWQv


 
